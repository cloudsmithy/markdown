[
  {
    "title": "未命名",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": null,
    "url": "obsidian://open?vault=markdown&file=%E6%9C%AA%E5%91%BD%E5%90%8D.md",
    "lang": "en",
    "filepath": "未命名.md",
    "content": "# 任务列表\n- [ ] 完成项目报告（截止：{{date}}）"
  },
  {
    "title": "README",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=README.md",
    "lang": "en",
    "filepath": "README.md",
    "content": ""
  },
  {
    "title": "未命名 1",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9C%AA%E5%91%BD%E5%90%8D%201.md",
    "lang": "en",
    "filepath": "未命名 1.md",
    "content": ""
  },
  {
    "title": "在家炖一锅暖心暖胃的排骨莲藕汤",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%BE%8E%E9%A3%9F/%E5%9C%A8%E5%AE%B6%E7%82%96%E4%B8%80%E9%94%85%E6%9A%96%E5%BF%83%E6%9A%96%E8%83%83%E7%9A%84%E6%8E%92%E9%AA%A8%E8%8E%B2%E8%97%95%E6%B1%A4.md",
    "lang": "en",
    "filepath": "美食/在家炖一锅暖心暖胃的排骨莲藕汤.md",
    "content": ""
  },
  {
    "title": "更新计划",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BE%85%E5%8F%91%E5%B8%83/%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92.md",
    "lang": "en",
    "filepath": "公众号待发布/更新计划.md",
    "content": ""
  },
  {
    "title": "重生之杜甫是穿越人",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BE%85%E5%8F%91%E5%B8%83/%E8%8D%89%E7%A8%BF/%E9%87%8D%E7%94%9F%E4%B9%8B%E6%9D%9C%E7%94%AB%E6%98%AF%E7%A9%BF%E8%B6%8A%E4%BA%BA.md",
    "lang": "en",
    "filepath": "公众号待发布/草稿/重生之杜甫是穿越人.md",
    "content": ""
  },
  {
    "title": "杭州游记",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BE%85%E5%8F%91%E5%B8%83/%E8%8D%89%E7%A8%BF/%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0.md",
    "lang": "en",
    "filepath": "公众号待发布/草稿/杭州游记.md",
    "content": "在西湖，历经前面的诗词，总是和现在对景观对的上的。\n\n\n苏小小墓的不远处，是秋瑾墓。\n\n白堤\n\n\n\n有处景点叫做断桥残雪，据说在冬季里其中一部分被大雪覆盖像似断桥而得名，从这走个出去，路边有人合唱，许嵩的歌。\n\n西泠\n----\n苏轼，杨万里，白居易"
  },
  {
    "title": "打工人吕布",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BE%85%E5%8F%91%E5%B8%83/%E8%8D%89%E7%A8%BF/%E6%89%93%E5%B7%A5%E4%BA%BA%E5%90%95%E5%B8%83.md",
    "lang": "en",
    "filepath": "公众号待发布/草稿/打工人吕布.md",
    "content": ""
  },
  {
    "title": "周游巴山楚水",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BE%85%E5%8F%91%E5%B8%83/%E8%8D%89%E7%A8%BF/%E5%91%A8%E6%B8%B8%E5%B7%B4%E5%B1%B1%E6%A5%9A%E6%B0%B4.md",
    "lang": "en",
    "filepath": "公众号待发布/草稿/周游巴山楚水.md",
    "content": ""
  },
  {
    "title": "飞牛OS虚拟机初体验",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/%E9%A3%9E%E7%89%9BOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C.md",
    "lang": "en",
    "filepath": "电子产品/飞牛OS虚拟机初体验.md",
    "content": ""
  },
  {
    "title": "追忆青春 - 黑群晖",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/%E8%BF%BD%E5%BF%86%E9%9D%92%E6%98%A5%20-%20%E9%BB%91%E7%BE%A4%E6%99%96.md",
    "lang": "en",
    "filepath": "电子产品/追忆青春 - 黑群晖.md",
    "content": ""
  },
  {
    "title": "Cudy RT3000 刷Openwrt",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/Cudy%20RT3000%20%E5%88%B7Openwrt.md",
    "lang": "en",
    "filepath": "电子产品/Cudy RT3000 刷Openwrt.md",
    "content": ""
  },
  {
    "title": "老式打印机改 Airprint 之cups",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/%E8%80%81%E5%BC%8F%E6%89%93%E5%8D%B0%E6%9C%BA%E6%94%B9%20Airprint%20%E4%B9%8Bcups.md",
    "lang": "en",
    "filepath": "电子产品/老式打印机改 Airprint 之cups.md",
    "content": ""
  },
  {
    "title": "NAS 体验文章",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/NAS%20%E4%BD%93%E9%AA%8C%E6%96%87%E7%AB%A0.md",
    "lang": "en",
    "filepath": "电子产品/NAS 体验文章.md",
    "content": ""
  },
  {
    "title": "电子产品",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81.md",
    "lang": "en",
    "filepath": "电子产品/电子产品.md",
    "content": ""
  },
  {
    "title": "Proxmox Virtual Environment (PVE) 虚拟机安装不完全指南",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/Proxmox%20Virtual%20Environment%20%28PVE%29%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.md",
    "lang": "en",
    "filepath": "电子产品/Proxmox Virtual Environment (PVE) 虚拟机安装不完全指南.md",
    "content": ""
  },
  {
    "title": "PXE 装机：iventoy 聊胜于无",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81/PXE%20%E8%A3%85%E6%9C%BA%EF%BC%9Aiventoy%20%E8%81%8A%E8%83%9C%E4%BA%8E%E6%97%A0.md",
    "lang": "en",
    "filepath": "电子产品/PXE 装机：iventoy 聊胜于无.md",
    "content": ""
  },
  {
    "title": "Typora 和Obsidian 自动使用 Github 做在线图床",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E8%BD%AF%E4%BB%B6%E6%95%88%E7%8E%87/Typora%20%E5%92%8CObsidian%20%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%20Github%20%E5%81%9A%E5%9C%A8%E7%BA%BF%E5%9B%BE%E5%BA%8A.md",
    "lang": "en",
    "filepath": "软件效率/Typora 和Obsidian 自动使用 Github 做在线图床.md",
    "content": ""
  },
  {
    "title": "手机网站存桌面",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E8%BD%AF%E4%BB%B6%E6%95%88%E7%8E%87/%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E5%AD%98%E6%A1%8C%E9%9D%A2.md",
    "lang": "en",
    "filepath": "软件效率/手机网站存桌面.md",
    "content": ""
  },
  {
    "title": "如何使用Iphone 拍摄 JPG格式的照片",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E8%BD%AF%E4%BB%B6%E6%95%88%E7%8E%87/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Iphone%20%E6%8B%8D%E6%91%84%20JPG%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%85%A7%E7%89%87.md",
    "lang": "en",
    "filepath": "软件效率/如何使用Iphone 拍摄 JPG格式的照片.md",
    "content": ""
  },
  {
    "title": "Easysearch 使用 AWS S3 进行快照还原及常见报错",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/Easysearch%20%E4%BD%BF%E7%94%A8%20AWS%20S3%20%E8%BF%9B%E8%A1%8C%E5%BF%AB%E7%85%A7%E8%BF%98%E5%8E%9F%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99.md",
    "lang": "en",
    "filepath": "极限科技/Easysearch 使用 AWS S3 进行快照还原及常见报错.md",
    "content": "## 3. 创建快照\n\n一旦 `my_s3_repository` 注册完成，就可以创建快照：\n\n```json\nPUT _snapshot/my_s3_repository/my_snapshot_001\n{\n\"indices\": \"my_index\",\n\"include_global_state\": false\n}\n```\n\n查看当前存储的快照：\n\n```json\nGET _snapshot/my_s3_repository/_all\n```\n\n\n## 5. 可能的错误与解决方案\n\n| **错误信息**                          | **可能原因**                  | **解决方案**                                                 |\n|-------------------------------------|-----------------------------|------------------------------------------------------------|\n| `repository_s3 plugin not installed` | 没有安装 `repository-s3` 插件 | 运行 `bin/elasticsearch-plugin install repository-s3` 并重启 |\n| `NoSuchBucket`                      | S3 存储桶不存在               | 确保 S3 存储桶名称正确                                       |\n| `AccessDenied`                      | 权限不足                      | 确保 S3 存储桶策略正确，检查 IAM 角色                        |\n| `index_closed_exception`            | 目标索引已关闭                | 先 `POST my_index/_open` 再恢复                              |\n| `index_already_exists_exception`    | 目标索引已存在                | 先 `DELETE my_index` 再恢复                                  |\n\n\n### 报错 2：索引已存在，无法恢复\n\n```json\n{\n\"error\": {\n\"root_cause\": [\n{\n\"type\": \"snapshot_restore_exception\",\n\"reason\": \"[my_s3_repository:1/9gIDCgSySwKzQqEYvaGM_w] cannot restore index [my_index] because an open index with same name already exists in the cluster. Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name\"\n}\n],\n\"type\": \"snapshot_restore_exception\",\n\"reason\": \"[my_s3_repository:1/9gIDCgSySwKzQqEYvaGM_w] cannot restore index [my_index] because an open index with same name already exists in the cluster. Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name\"\n},\n\"status\": 500\n}\n```\n\n#### **解决方案**：\n\n1. **删除现有索引后恢复**：\n```bash\nDELETE /my_index\n```\n2. **关闭索引后恢复**：\n```bash\nPOST /my_index/_close\n```\n3. **恢复为新的索引名称**：\n```json\nPOST _snapshot/my_s3_repository/1/_restore\n{\n\"indices\": \"my_index\",\n\"rename_pattern\": \"my_index\",\n\"rename_replacement\": \"restored_my_index\"\n}\n```\n\n\n| **API**                                                 | **用途**       |\n| ------------------------------------------------------- | -------------- |\n| `GET _snapshot/_all`                                    | 查看所有存储库 |\n| `GET _snapshot/my_s3_repository`                        | 查看特定存储库 |\n| `PUT _snapshot/my_s3_repository`                        | 创建存储库     |\n| `DELETE _snapshot/my_s3_repository`                     | 删除存储库     |\n| `PUT _snapshot/my_s3_repository/snapshot_001`           | 创建快照       |\n| `GET _snapshot/my_s3_repository/_all`                   | 查看所有快照   |\n| `GET _snapshot/my_s3_repository/snapshot_001`           | 查看快照详情   |\n| `DELETE _snapshot/my_s3_repository/snapshot_001`        | 删除快照       |\n| `POST _snapshot/my_s3_repository/snapshot_001/_restore` | 还原快照       |\n| `GET _snapshot/_status`                                 |     查看快照状态           |\n\n\n\n\n\n🚀 通过本文，你可以高效地使用 **AWS S3 进行 Easysearch 快照备份和恢复**，并排查可能的错误，确保集群数据安全无忧！"
  },
  {
    "title": "使用 INFINI Console 配置集群监控 Webhook 通知指南",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/%E4%BD%BF%E7%94%A8%20INFINI%20Console%20%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%20Webhook%20%E9%80%9A%E7%9F%A5%E6%8C%87%E5%8D%97.md",
    "lang": "en",
    "filepath": "极限科技/使用 INFINI Console 配置集群监控 Webhook 通知指南.md",
    "content": ""
  },
  {
    "title": "sss",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "极限",
    "subcategory": "",
    "tags": [
      "极限科技"
    ],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E8%AF%AD%E6%96%99%E5%BA%93%EF%BC%9A%E9%80%9A%E8%BF%87Coco%20AI%20Server%20%E5%AE%9E%E7%8E%B0%20Notion%20%E7%AC%94%E8%AE%B0%20RAG%20%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD.md",
    "lang": "en",
    "filepath": "极限科技/打造智能语料库：通过Coco AI Server 实现 Notion 笔记 RAG 检索功能.md",
    "content": "本文将详细介绍如何将 Notion 作为语料库，部署 CoCo Server 的 RAG（Retrieval-Augmented Generation）功能。我们将使用 Easysearch 作为语料库存储 Notion 素材，并通过 ollama 进行 LLM 推理。\n\n### 1. 环境准备\n\n#### 1.1 启动 Easysearch\n首先，启动 Easysearch 作为语料库，用于存储 Notion 的素材。\n\n#### 1.2 启动 ollama\n接下来，启动 ollama，用于进行 LLM 推理。\n\n#### 1.3 启动 CoCo Server\n启动 CoCo Server，默认端口为 9000。\n\n![CoCo Server 启动界面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217142649790.png)\n\n### 2. CoCo App 连接与登录\n\n#### 2.1 连接 CoCo Server\n通过 CoCo App 连接 Server，并输入相关信息。\n\n![CoCo App 连接界面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217142816787.png)\n\n#### 2.2 使用 GitHub 登录\n登录时选择使用 GitHub 账号进行认证。\n\n![GitHub 登录界面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217142837884.png)\n\n#### 2.3 获取 OAuth 回调信息\n登录成功后，系统会重定向并返回 OAuth 回调信息。我们需要抓取以下信息，后续将使用该 token 换取访问 CoCo Server AI 的 key：\n\n```\ncoco://oauth_callback?code=cupibub55o1cfqbveps0q804ai6aj14in3u91xjhvuk8s7ixirjsq2j9mmyyeut91nmgjwz0b494ngpk&request_id=eb94762b-f054-4710-9c6cf20889d3&provider=coco-cloud\n```\n\n![OAuth 回调信息](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217142925920.png)\n\n### 3. 认证流程\n\n#### 3.1 获取临时 Token\n首先，访问以下 URL 获取临时 Token：\n\n```\nhttp://localhost:9000/sso/login/github?provider=coco-cloud&product=coco&request_id=dd9825e1-ebd3-4c84-9e3f-7ccb0421c508\n```\n\n该请求将返回一个临时 Token，例如 `XXABC`。\n\n#### 3.2 换取 Access Token\n使用上一步获取的临时 Token，通过以下命令换取 Access Token：\n\n```bash\ncurl -H'X-API-TOKEN: XXABC' \"http://localhost:9000/auth/request_access_token?request_id=dd9825e1-ebd3-4c84-9e3f-7ccb0421c508\"\n```\n\n返回的 Token 即为所需的 Access Token。\n\n#### 3.3 使用 Postman 获取 Token\n在 Postman 中执行上述步骤，获取 `access_token` 和过期时间。\n\n![Postman 获取 Token](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217143134946.png)\n\n### 4. 使用 Python 脚本自动化认证流程\n\n以下 Python 脚本可用于自动化解析 OAuth 回调信息并获取 Access Token：\n\n```python\nimport requests\n\ndef parse_oauth_callback(url):\nquery_params = {param.split('=')[0]: param.split('=')[1] for param in url.split('?')[1].split('&')}\ncode = query_params.get(\"code\")\nrequest_id = query_params.get(\"request_id\")\nreturn code, request_id\n\ndef request_access_token(code, base_url, request_id):\nurl = f\"{base_url}/auth/request_access_token?request_id={request_id}\"\nheaders = {\"X-API-TOKEN\": code}\nresponse = requests.get(url, headers=headers)\nreturn response.json()\n\n# 示例输入\noauth_callback_url = \"\"\"\ncoco://oauth_callback?code=cupibub55o1cfqbveps0q804ai6aj151wu4in3u91xjhvuk8s7ixirjsq2j9mmyyeut91nmgjwz0b494ngpk&request_id=eb94762b-f054-4710-9c6a-0cf2088729d3&provider=coco-cloud\n\"\"\"\nbase_url = \"http://localhost:9000\"\n\n# 解析 code 和 request_id\ncode, request_id = parse_oauth_callback(oauth_callback_url)\n\n# 发送请求\ntoken_response = request_access_token(code, base_url, request_id)\nprint(token_response)\n```\n\n### 5. 查看用户信息\n\n使用获取的 `access_key` 可以查看用户信息：\n\n```python\nimport requests\n\nurl = \"http://localhost:9000/account/profile\"\n\npayload = {}\nheaders = {\n'X-API-TOKEN': 'cupichb55o1cfqbveq90zwomyxs791ul3esbxxt480c8dzgvdtjtvmcnsld4a5v0wvx9l9ofcf1'\n}\n\nresponse = requests.request(\"GET\", url, headers=headers, data=payload)\n\nprint(response.text)\n```\n\n### 6. 注册 Notion Connector\n\n以下 Python 脚本用于注册 Notion Connector：\n\n```python\nimport requests\nimport json\n\ndef update_connector(base_url, api_token, connector_name, data):\nurl = f\"{base_url}/connector/{connector_name}?replace=true\"\nheaders = {\n\"X-API-TOKEN\": api_token,\n\"Content-Type\": \"application/json\"\n}\nresponse = requests.put(url, headers=headers, data=json.dumps(data))\nreturn response.json()\n\nbase_url = \"http://localhost:9000\"\napi_token = \"<token>\"\n\nnotion_data = {\n\"name\": \"Notion Docs Connector\",\n\"description\": \"Fetch the docs metadata for notion.\",\n\"icon\": \"/assets/connector/notion/icon.png\",\n\"category\": \"website\",\n\"tags\": [\"docs\", \"notion\", \"web\"],\n\"url\": \"http://coco.rs/connectors/notion\",\n\"assets\": {\n\"icons\": {\n\"default\": \"/assets/connector/notion/icon.png\",\n\"web_page\": \"/assets/connector/notion/icon.png\",\n\"database\": \"/assets/connector/notion/database.png\",\n\"page\": \"/assets/connector/notion/page.png\"\n}\n}\n}\n\nresponse_notion = update_connector(base_url, api_token, \"notion\", notion_data)\nprint(response_notion)\n```\n在Easysearch中看到创建Notion的Connector：\n\n![image.png](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/20250217213310.png)\n\n### 7. 配置 Notion Connector\n\n#### 7.1 修改 Notion 配置文件\n修改 Notion 配置文件以激活检索功能：\n\n![Notion 配置文件修改](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217210840104.png)\n\n#### 7.2 申请 Notion API Key\n在 Notion 官网申请 API Key：[Notion API Key](https://www.notion.so/profile/integrations)\n\n![Notion API Key 申请](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217212252851.png)\n\n#### 7.3 配置权限与展示 API Key\n配置完成后，设置权限并展示 API Key：\n\n![Notion API Key 展示](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217212349650.png)\n\n#### 7.4 配置 Notion Connector\n使用以下 Python 脚本配置 Notion Connector：\n\n```python\nimport requests\nimport json\n\ndef create_datasource(base_url, api_token, data):\nurl = f\"{base_url}/datasource/\"\nheaders = {\n\"X-API-TOKEN\": api_token,\n\"Content-Type\": \"application/json\"\n}\nresponse = requests.post(url, headers=headers, data=json.dumps(data))\nreturn response.json()\n\n# 示例输入\nbase_url = \"http://localhost:9000\"\napi_token = \"<api-key>\"\n\ndatasource_data = {\n\"name\": \"My Notion\",\n\"type\": \"connector\",\n\"connector\": {\n\"id\": \"notion\",\n\"config\": {\n\"token\": \"<notion token>\"\n}\n}\n}\n\n# 发送 POST 请求\nresponse = create_datasource(base_url, api_token, datasource_data)\nprint(response)\n```\n\n#### 7.5 设置 Notion 集成\n在 Notion 中设置集成，以便 CoCo Server 能够搜索到相关内容：\n\n![Notion 集成设置](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217212508943.png)\n\n\n### 8. 验证检索功能\n\n![image.png](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/20250217213558.png)\n\n![image.png](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/20250217213454.png)\n\n![](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/20250217213454.png)\n\n#### 8.1 查看 CoCo Server 日志\n在 CoCo Server 日志中确认 Notion 检索功能已启用：\n\n![CoCo Server 日志](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217210810825.png)\n\n#### 8.2 在搜索栏检索\n最后，您可以在搜索栏中检索到 Notion 笔记内容：\n\n![Notion 检索结果](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250217211620791.png)\n\n至此，您已成功将 Notion 作为语料库部署到 CoCo Server 的 RAG 功能中。"
  },
  {
    "title": "实现 INFINI Console 与 GitHub 的单点登录集成：一站式身份验证解决方案",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/%E5%AE%9E%E7%8E%B0%20INFINI%20Console%20%E4%B8%8E%20GitHub%20%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90%EF%BC%9A%E4%B8%80%E7%AB%99%E5%BC%8F%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md",
    "lang": "en",
    "filepath": "极限科技/实现 INFINI Console 与 GitHub 的单点登录集成：一站式身份验证解决方案.md",
    "content": "## 三、单点登录流程演示\n\n### 1. 访问 INFINI Console\n- 打开浏览器，访问 `http://localhost:9000`。\n- 点击 **单点登录** 按钮，进入登录流程。\n\n![单点登录入口](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250222112609439.png)\n\n### 2. 使用 GitHub 登录\n- 点击 **GitHub** 图标，跳转至 GitHub 登录页面。\n\n![GitHub 登录界面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250222112032548.png)\n\n### 3. 授权应用访问\n- 在 GitHub 授权页面，确认授权 INFINI Console 访问您的 GitHub 账户。\n\n![GitHub 授权页面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250222112039508.png)\n\n### 4. 登录成功\n- 授权成功后，系统将自动跳转回 INFINI Console，并显示您的 GitHub 用户名。\n\n![登录成功页面](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250222112009983.png)\n\n![显示 GitHub 用户名](https://raw.githubusercontent.com/Xu-Hardy/picgo-imh/master/image-20250222112422743.png)"
  },
  {
    "title": "极限科技",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80.md",
    "lang": "en",
    "filepath": "极限科技/极限科技.md",
    "content": ""
  },
  {
    "title": "Coco AI APP 初体验：开启智能知识管理新篇章",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/Coco%20AI%20APP%20%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%9A%E5%BC%80%E5%90%AF%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E6%96%B0%E7%AF%87%E7%AB%A0.md",
    "lang": "en",
    "filepath": "极限科技/Coco AI APP 初体验：开启智能知识管理新篇章.md",
    "content": ""
  },
  {
    "title": "Macbook Pro快速搭建Easysearch学习环境",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/Macbook%20Pro%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAEasysearch%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83.md",
    "lang": "en",
    "filepath": "极限科技/Macbook Pro快速搭建Easysearch学习环境.md",
    "content": ""
  },
  {
    "title": "推荐给 Easysearch 新用户的几个 Elasticsearch 可视化工具",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/%E6%8E%A8%E8%8D%90%E7%BB%99%20Easysearch%20%E6%96%B0%E7%94%A8%E6%88%B7%E7%9A%84%E5%87%A0%E4%B8%AA%20Elasticsearch%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7.md",
    "lang": "en",
    "filepath": "极限科技/推荐给 Easysearch 新用户的几个 Elasticsearch 可视化工具.md",
    "content": ""
  },
  {
    "title": "云端秘境：EC2的奇幻之旅",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=AI%20%E8%AE%B2%20AWS/%E4%BA%91%E7%AB%AF%E7%A7%98%E5%A2%83%EF%BC%9AEC2%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85.md",
    "lang": "en",
    "filepath": "AI 讲 AWS/云端秘境：EC2的奇幻之旅.md",
    "content": "## 骑士的铠甲与武器\n艾伦的战士虽然已经苏醒，但他依然是一名“裸装战士”，缺少防护和装备。守护者带着艾伦来到**EC2兵工坊**，指向三样关键的装备：\n\n### 1. EBS（Elastic Block Store）- 弹性块存储\n“这是你的战士的背包，它可以存放所有的装备和战利品。”\n\n**EBS是EC2的磁盘存储，支持多种模式：**\n- **gp3（通用SSD）**：适用于大部分场景，性价比高。\n- **io2（高性能SSD）**：适合金融、数据库等高IO需求的场景。\n- **st1（磁盘存储）**：适合日志存储、备份等大容量需求。\n\n艾伦选择了 **gp3 100GB** 作为他的战士存储空间，并在上面安装了Nginx网站服务。\n\n### 2. Security Group - 安全组护盾\n“战士需要护盾，否则他可能会被敌人攻击。”\n\n**Security Group 是 EC2 的防火墙，控制外界访问。**\n艾伦设定：\n- 允许 **80 和 443 端口**（网站访问）\n- 仅允许自己通过 **22 端口**（SSH远程管理）\n\n### 3. Key Pair - 密钥对\n“你需要一把魔法钥匙，才能命令你的战士。”\n\n**密钥对（Key Pair）** 是 EC2 的 SSH 认证方式，艾伦下载了一个 **.pem 文件**，妥善保管，以便能安全地远程管理他的实例。"
  },
  {
    "title": "使用Nginx获取并返回客户端的公网IP地址",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/%E4%BD%BF%E7%94%A8Nginx%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%85%AC%E7%BD%91IP%E5%9C%B0%E5%9D%80.md",
    "lang": "en",
    "filepath": "开源软件/使用Nginx获取并返回客户端的公网IP地址.md",
    "content": ""
  },
  {
    "title": "5. 数据验证与序列化",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/5.%20%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/5. 数据验证与序列化.md",
    "content": "### **5.2 序列化与反序列化**\n\n#### **5.2.1 序列化**\n序列化是将 Python 对象转换为 JSON 格式的过程。\n\n- **示例：序列化用户对象**\n```python\nuser = {'id': 1, 'name': 'Alice', 'age': 25}\nschema = UserSchema()\nresult = schema.dump(user)\nprint(result)  # 输出：{'id': 1, 'name': 'Alice', 'age': 25}\n```\n\n- **序列化多个对象**：\n```python\nusers = [{'id': 1, 'name': 'Alice', 'age': 25}, {'id': 2, 'name': 'Bob', 'age': 30}]\nschema = UserSchema(many=True)\nresult = schema.dump(users)\nprint(result)  # 输出：[{'id': 1, 'name': 'Alice', 'age': 25}, {'id': 2, 'name': 'Bob', 'age': 30}]\n```\n\n#### **5.2.2 反序列化**\n反序列化是将 JSON 数据转换为 Python 对象的过程。\n\n- **示例：反序列化用户数据**\n```python\ndata = {'name': 'Alice', 'age': 25}\nschema = UserSchema()\nresult = schema.load(data)\nprint(result)  # 输出：{'name': 'Alice', 'age': 25}\n```\n\n- **处理嵌套数据**：\n```python\nclass AddressSchema(Schema):\ncity = fields.Str(required=True)\nstreet = fields.Str(required=True)\n\nclass UserSchema(Schema):\nname = fields.Str(required=True)\nage = fields.Int(required=True)\naddress = fields.Nested(AddressSchema)\n\ndata = {'name': 'Alice', 'age': 25, 'address': {'city': 'Shanghai', 'street': 'Main St'}}\nschema = UserSchema()\nresult = schema.load(data)\nprint(result)  # 输出：{'name': 'Alice', 'age': 25, 'address': {'city': 'Shanghai', 'street': 'Main St'}}\n```\n\n\n## **完整示例**\n\n以下是一个结合数据验证和序列化的完整示例：\n```python\nfrom flask import Flask, request, jsonify\nfrom marshmallow import Schema, fields, ValidationError\n\napp = Flask(__name__)\n\nclass UserSchema(Schema):\nid = fields.Int(dump_only=True)\nname = fields.Str(required=True)\nage = fields.Int(required=True)\n\n@validates('age')\ndef validate_age(self, value):\nif value < 0:\nraise ValidationError('Age must be a positive number.')\n\nuser_schema = UserSchema()\n\n@app.route('/users', methods=['POST'])\ndef create_user():\ndata = request.get_json()\ntry:\nresult = user_schema.load(data)\nreturn jsonify(result), 201\nexcept ValidationError as err:\nreturn jsonify(err.messages), 400\n\nif __name__ == '__main__':\napp.run(debug=True)\n```"
  },
  {
    "title": "2. 环境准备",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/2.%20%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/2. 环境准备.md",
    "content": "### **2.2 创建虚拟环境**\n\n虚拟环境（Virtual Environment）是 Python 项目的独立运行环境，可以避免不同项目之间的依赖冲突。以下是创建虚拟环境的步骤：\n\n#### **2.2.1 创建虚拟环境**\n1. 打开终端，进入你的项目目录：\n```bash\ncd path/to/your/project\n```\n\n2. 创建虚拟环境：\n- 在 macOS/Linux 上：\n```bash\npython3 -m venv venv\n```\n- 在 Windows 上：\n```bash\npython -m venv venv\n```\n这会在项目目录下创建一个名为 `venv` 的文件夹，里面包含虚拟环境的所有文件。\n\n#### **2.2.2 激活虚拟环境**\n1. 在 macOS/Linux 上：\n```bash\nsource venv/bin/activate\n```\n2. 在 Windows 上：\n```bash\nvenv\\Scripts\\activate\n```\n激活后，终端提示符会显示虚拟环境名称（如 `(venv)`）。\n\n#### **2.2.3 退出虚拟环境**\n如果需要退出虚拟环境，可以运行以下命令：\n```bash\ndeactivate\n```\n\n\n## **总结**\n通过本章的学习，你已经完成了以下准备工作：\n1. 安装了 Python 和 Flask。\n2. 创建了虚拟环境，确保项目依赖的独立性。\n3. 安装了常用的 Flask 扩展库，为后续开发打下基础。\n\n接下来，我们将进入 **3. Flask 基础**，学习如何构建第一个 Flask 应用。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄\n\n在开始构建 Flask RESTful API 之前，我们需要准备好开发环境。本章将详细介绍如何安装 Python 和 Flask、创建虚拟环境以及安装常用的扩展库。\n\n\n### **2.2 创建虚拟环境**\n\n虚拟环境（Virtual Environment）是 Python 项目的独立运行环境，可以避免不同项目之间的依赖冲突。以下是创建虚拟环境的步骤：\n\n#### **2.2.1 创建虚拟环境**\n1. 打开终端，进入你的项目目录：\n```bash\ncd path/to/your/project\n```\n\n2. 创建虚拟环境：\n- 在 macOS/Linux 上：\n```bash\npython3 -m venv venv\n```\n- 在 Windows 上：\n```bash\npython -m venv venv\n```\n这会在项目目录下创建一个名为 `venv` 的文件夹，里面包含虚拟环境的所有文件。\n\n#### **2.2.2 激活虚拟环境**\n1. 在 macOS/Linux 上：\n```bash\nsource venv/bin/activate\n```\n2. 在 Windows 上：\n```bash\nvenv\\Scripts\\activate\n```\n激活后，终端提示符会显示虚拟环境名称（如 `(venv)`）。\n\n#### **2.2.3 退出虚拟环境**\n如果需要退出虚拟环境，可以运行以下命令：\n```bash\ndeactivate\n```\n\n\n## **总结**\n通过本章的学习，你已经完成了以下准备工作：\n1. 安装了 Python 和 Flask。\n2. 创建了虚拟环境，确保项目依赖的独立性。\n3. 安装了常用的 Flask 扩展库，为后续开发打下基础。\n\n接下来，我们将进入 **3. Flask 基础**，学习如何构建第一个 Flask 应用。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "12. 实战项目",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/12.%20%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/12. 实战项目.md",
    "content": "### **12.2 设计数据库模型**\n\n#### **12.2.1 用户表（User）**\n| 字段名     | 类型         | 描述           |\n|------------|--------------|----------------|\n| id         | Integer      | 主键           |\n| username   | String(50)   | 用户名，唯一   |\n| password   | String(100)  | 密码（加密）   |\n| email      | String(100)  | 邮箱，唯一     |\n\n#### **12.2.2 产品表（Product）**\n| 字段名     | 类型         | 描述           |\n|------------|--------------|----------------|\n| id         | Integer      | 主键           |\n| name       | String(100)  | 产品名称       |\n| price      | Float        | 产品价格       |\n| user_id    | Integer      | 外键，关联用户 |\n\n#### **12.2.3 数据库模型代码**\n```python\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass User(db.Model):\nid = db.Column(db.Integer, primary_key=True)\nusername = db.Column(db.String(50), unique=True, nullable=False)\npassword = db.Column(db.String(100), nullable=False)\nemail = db.Column(db.String(100), unique=True, nullable=False)\nproducts = db.relationship('Product', backref='user', lazy=True)\n\nclass Product(db.Model):\nid = db.Column(db.Integer, primary_key=True)\nname = db.Column(db.String(100), nullable=False)\nprice = db.Column(db.Float, nullable=False)\nuser_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n```\n\n\n### **12.4 编写测试用例**\n\n#### **12.4.1 安装测试工具**\n```bash\npip install pytest Flask-Testing\n```\n\n#### **12.4.2 编写单元测试**\n- **测试用户注册**：\n```python\ndef test_register(self):\nresponse = self.app.post('/register', json={\n'username': 'Alice',\n'password': 'password',\n'email': 'alice@example.com'\n})\nself.assertEqual(response.status_code, 201)\nself.assertIn('User registered successfully', response.get_data(as_text=True))\n```\n\n- **测试用户登录**：\n```python\ndef test_login(self):\nself.app.post('/register', json={\n'username': 'Alice',\n'password': 'password',\n'email': 'alice@example.com'\n})\nresponse = self.app.post('/login', json={\n'username': 'Alice',\n'password': 'password'\n})\nself.assertEqual(response.status_code, 200)\nself.assertIn('access_token', response.get_data(as_text=True))\n```\n\n\n## **总结**\n通过本章的学习，你已经完成了一个完整的 Flask 项目，包括需求分析、数据库设计、核心功能实现、测试用例编写以及部署上线。希望这个实战项目能帮助你更好地理解 Flask 和 RESTful API 的开发流程。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "4. 构建第一个 RESTful API",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/4.%20%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%20RESTful%20API.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/4. 构建第一个 RESTful API.md",
    "content": "### **4.2 定义资源类**\n\n#### **4.2.1 什么是资源类？**\n资源类是 Flask-RESTful 的核心概念。每个资源类对应一个 API 端点，并定义了对该资源的操作（如 GET、POST、PUT、DELETE）。\n\n#### **4.2.2 定义资源类的步骤**\n1. 继承 `Resource` 类。\n2. 实现 HTTP 方法（如 `get`、`post`、`put`、`delete`）。\n3. 将资源类添加到 `Api` 实例中。\n\n#### **4.2.3 示例：用户资源类**\n以下是一个用户资源类的示例：\n```python\nfrom flask_restful import Resource\n\nclass UserResource(Resource):\ndef get(self, user_id=None):\nif user_id:\nreturn {'user_id': user_id, 'name': 'Alice'}\nelse:\nreturn {'users': [{'id': 1, 'name': 'Alice'}, {'id': 2, 'name': 'Bob'}]}\n\ndef post(self):\nreturn {'message': 'User created'}, 201\n\ndef put(self, user_id):\nreturn {'message': f'User {user_id} updated'}\n\ndef delete(self, user_id):\nreturn {'message': f'User {user_id} deleted'}\n```\n\n#### **4.2.4 添加资源类到 Api**\n将资源类添加到 `Api` 实例中，并指定 URL 路径：\n```python\napi.add_resource(UserResource, '/users', '/users/<int:user_id>')\n```\n\n- `/users`：获取所有用户或创建新用户。\n- `/users/<int:user_id>`：获取、更新或删除指定用户。\n\n\n### **4.4 返回 JSON 数据**\n\n#### **4.4.1 自动转换为 JSON**\nFlask-RESTful 会自动将 Python 字典转换为 JSON 格式。例如：\n```python\ndef get(self):\nreturn {'message': 'Hello, World!'}\n```\n返回的 JSON 数据：\n```json\n{\n\"message\": \"Hello, World!\"\n}\n```\n\n#### **4.4.2 自定义状态码**\n可以通过返回元组来指定状态码：\n```python\ndef post(self):\nreturn {'message': 'User created'}, 201\n```\n返回的 JSON 数据和状态码：\n```json\n{\n\"message\": \"User created\"\n}\n```\n状态码：`201 Created`\n\n#### **4.4.3 返回列表**\n可以直接返回列表，Flask-RESTful 会将其转换为 JSON 数组：\n```python\ndef get(self):\nreturn [{'id': 1, 'name': 'Alice'}, {'id': 2, 'name': 'Bob'}]\n```\n返回的 JSON 数据：\n```json\n[\n{\n\"id\": 1,\n\"name\": \"Alice\"\n},\n{\n\"id\": 2,\n\"name\": \"Bob\"\n}\n]\n```\n\n\n## **总结**\n通过本章的学习，你已经掌握了以下内容：\n1. 如何使用 Flask-RESTful 构建 RESTful API。\n2. 如何定义资源类并处理 GET、POST、PUT、DELETE 请求。\n3. 如何返回 JSON 数据。\n\n接下来，我们将进入 **5. 数据验证与序列化**，学习如何使用 Marshmallow 进行数据验证和序列化。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "7. 用户认证与授权",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/7.%20%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/7. 用户认证与授权.md",
    "content": "### **7.2 用户注册与登录**\n\n#### **7.2.1 用户注册**\n用户注册时，将用户信息保存到数据库。\n\n- **示例：用户注册路由**\n```python\nfrom flask import request, jsonify\nfrom werkzeug.security import generate_password_hash\n\n@app.route('/register', methods=['POST'])\ndef register():\ndata = request.get_json()\nusername = data.get('username')\npassword = data.get('password')\nemail = data.get('email')\n\nif User.query.filter_by(username=username).first():\nreturn jsonify({'message': 'Username already exists'}), 400\n\nnew_user = User(\nusername=username,\npassword=generate_password_hash(password),  # 加密密码\nemail=email\n)\ndb.session.add(new_user)\ndb.session.commit()\n\nreturn jsonify({'message': 'User registered successfully'}), 201\n```\n\n#### **7.2.2 用户登录**\n用户登录时，验证用户名和密码，并生成 JWT。\n\n- **示例：用户登录路由**\n```python\nfrom flask_jwt_extended import create_access_token\nfrom werkzeug.security import check_password_hash\n\n@app.route('/login', methods=['POST'])\ndef login():\ndata = request.get_json()\nusername = data.get('username')\npassword = data.get('password')\n\nuser = User.query.filter_by(username=username).first()\nif user and check_password_hash(user.password, password):\naccess_token = create_access_token(identity=username)\nreturn jsonify(access_token=access_token), 200\nelse:\nreturn jsonify({'message': 'Invalid credentials'}), 401\n```\n\n- **create_access_token**：生成 JWT，`identity` 参数用于标识用户。\n\n\n### **7.4 Token 刷新与黑名单**\n\n#### **7.4.1 Token 刷新**\nJWT 的有效期通常较短，为了提升用户体验，可以通过刷新 Token 来延长会话。\n\n- **示例：刷新 Token**\n```python\nfrom flask_jwt_extended import create_refresh_token, jwt_refresh_token_required, get_jwt_identity\n\n@app.route('/refresh', methods=['POST'])\n@jwt_refresh_token_required\ndef refresh():\ncurrent_user = get_jwt_identity()\nnew_access_token = create_access_token(identity=current_user)\nreturn jsonify(access_token=new_access_token), 200\n```\n\n- **jwt_refresh_token_required**：确保请求携带有效的刷新 Token。\n- **create_access_token**：生成新的访问 Token。\n\n#### **7.4.2 Token 黑名单**\n为了防止 Token 被滥用，可以将失效的 Token 加入黑名单。\n\n- **示例：实现黑名单**\n```python\nfrom flask_jwt_extended import get_raw_jwt\n\nblacklist = set()\n\n@jwt.token_in_blacklist_loader\ndef check_if_token_in_blacklist(decrypted_token):\njti = decrypted_token['jti']\nreturn jti in blacklist\n\n@app.route('/logout', methods=['DELETE'])\n@jwt_required()\ndef logout():\njti = get_raw_jwt()['jti']\nblacklist.add(jti)\nreturn jsonify({'message': 'Successfully logged out'}), 200\n```\n\n- **jwt.token_in_blacklist_loader**：检查 Token 是否在黑名单中。\n- **get_raw_jwt**：获取当前 Token 的原始数据。\n\n\n## **总结**\n通过本章的学习，你已经掌握了以下内容：\n1. 如何使用 Flask-JWT-Extended 实现 JWT 认证。\n2. 如何实现用户注册和登录功能。\n3. 如何保护路由并验证用户身份。\n4. 如何实现 Token 刷新和黑名单功能。\n\n接下来，我们将进入 **8. 错误处理与日志**，学习如何处理错误和记录日志。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "13. 附录",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/13.%20%E9%99%84%E5%BD%95.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/13. 附录.md",
    "content": "### **13.2 参考文档与学习资源**\n\n以下是一些推荐的参考文档和学习资源，帮助你深入学习 Flask 和相关技术：\n\n#### **官方文档**\n1. **Flask 官方文档**：\n- [Flask Documentation](https://flask.palletsprojects.com/)\n- 包含 Flask 的核心概念、API 参考和示例代码。\n\n2. **Flask-SQLAlchemy 官方文档**：\n- [Flask-SQLAlchemy Documentation](https://flask-sqlalchemy.palletsprojects.com/)\n- 提供数据库操作和模型定义的详细说明。\n\n3. **Flask-JWT-Extended 官方文档**：\n- [Flask-JWT-Extended Documentation](https://flask-jwt-extended.readthedocs.io/)\n- 详细介绍 JWT 认证和授权的实现方法。\n\n4. **Flask-RESTful 官方文档**：\n- [Flask-RESTful Documentation](https://flask-restful.readthedocs.io/)\n- 提供 RESTful API 开发的详细指南。\n\n#### **学习资源**\n1. **Flask Mega-Tutorial**：\n- [Flask Mega-Tutorial by Miguel Grinberg](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world)\n- 一个非常详细的 Flask 教程，适合初学者和中级开发者。\n\n2. **Real Python Flask Tutorials**：\n- [Real Python Flask Tutorials](https://realpython.com/tutorials/flask/)\n- 提供一系列高质量的 Flask 教程和文章。\n\n3. **Full Stack Python**：\n- [Full Stack Python - Flask](https://www.fullstackpython.com/flask.html)\n- 提供 Flask 的全面介绍和相关资源链接。\n\n4. **YouTube 视频教程**：\n- [Flask Tutorial by Corey Schafer](https://www.youtube.com/playlist?list=PL-osiE80TeTs4UjLw5MM6OjgkjFeUxCYH)\n- 一个非常受欢迎的 Flask 视频教程系列。\n\n\n## **总结**\n本附录提供了一些常用的 Flask 扩展库、参考文档与学习资源，以及常见问题解答。希望这些内容能帮助你更好地理解和使用 Flask。如果你有其他问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "10. API 文档与测试",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/10.%20API%20%E6%96%87%E6%A1%A3%E4%B8%8E%E6%B5%8B%E8%AF%95.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/10. API 文档与测试.md",
    "content": "responses:\n200:\ndescription: A greeting message\n\"\"\"\nreturn 'Hello, World!'\n```\n\n#### **10.1.5 访问 Swagger UI**\n启动应用后，访问 `http://127.0.0.1:5000/apidocs`，即可看到自动生成的 Swagger 文档。\n\n\n### **10.3 使用 Postman 测试 API**\n\n#### **10.3.1 什么是 Postman？**\nPostman 是一个流行的 API 测试工具，支持发送 HTTP 请求、查看响应和调试 API。\n\n#### **10.3.2 使用 Postman 测试 API**\n1. **下载并安装 Postman**：\n- 访问 [Postman 官方网站](https://www.postman.com/downloads/)，下载并安装 Postman。\n\n2. **创建请求**：\n- 打开 Postman，点击 `New` -> `Request`，创建一个新的请求。\n- 输入请求 URL（如 `http://127.0.0.1:5000/register`）。\n- 选择请求方法（如 `POST`）。\n\n3. **设置请求体**：\n- 选择 `Body` -> `raw`，并选择 `JSON` 格式。\n- 输入 JSON 数据：\n```json\n{\n\"username\": \"Alice\",\n\"password\": \"password\",\n\"email\": \"alice@example.com\"\n}\n```\n\n4. **发送请求**：\n- 点击 `Send` 按钮，查看响应结果。\n\n5. **保存请求**：\n- 点击 `Save` 按钮，将请求保存到集合中，方便后续测试。\n\nparameters:\n- name: body\nin: body\nrequired: true\nschema:\ntype: object\nproperties:\nusername:\ntype: string\npassword:\ntype: string\nemail:\ntype: string\nresponses:\n201:\ndescription: User registered successfully\n400:\ndescription: Username or email already exists\n\"\"\"\ndata = request.get_json()\nusername = data.get('username')\npassword = data.get('password')\nemail = data.get('email')\n\nif User.query.filter_by(username=username).first():\nreturn jsonify({'message': 'Username already exists'}), 400\n\nnew_user = User(username=username, password=password, email=email)\ndb.session.add(new_user)\ndb.session.commit()\n\nreturn jsonify({'message': 'User registered successfully'}), 201\n\nif __name__ == '__main__':\napp.run(debug=True)\n```"
  },
  {
    "title": "3. Flask 基础",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/3.%20Flask%20%E5%9F%BA%E7%A1%80.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/3. Flask 基础.md",
    "content": "### **3.2 路由与视图函数**\n\n#### **3.2.1 路由**\n路由是 URL 和视图函数之间的映射。Flask 使用 `@app.route()` 装饰器来定义路由。\n\n- **基本路由**：\n```python\n@app.route('/')\ndef home():\nreturn 'Welcome to the Home Page!'\n```\n\n- **带参数的路由**：\n```python\n@app.route('/user/<username>')\ndef show_user_profile(username):\nreturn f'User: {username}'\n```\n\n- **指定 HTTP 方法**：\n```python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\nif request.method == 'POST':\nreturn 'Login POST'\nelse:\nreturn 'Login GET'\n```\n\n#### **3.2.2 视图函数**\n视图函数是处理请求并返回响应的函数。每个路由对应一个视图函数。\n\n- **返回字符串**：\n```python\n@app.route('/')\ndef home():\nreturn 'Hello, World!'\n```\n\n- **返回 JSON**：\n```python\nfrom flask import jsonify\n\n@app.route('/data')\ndef data():\nreturn jsonify({'name': 'Alice', 'age': 25})\n```\n\n\n### **3.4 调试模式**\n\n调试模式是 Flask 提供的一个开发工具，可以帮助开发者快速定位和修复问题。\n\n#### **3.4.1 启用调试模式**\n在运行应用时，设置 `debug=True`：\n```python\nif __name__ == '__main__':\napp.run(debug=True)\n```\n\n#### **3.4.2 调试模式的功能**\n1. **自动重启**：\n- 当代码发生变化时，Flask 会自动重启应用，无需手动停止和启动。\n\n2. **错误页面**：\n- 如果应用发生错误，Flask 会显示一个详细的错误页面，包含错误信息和堆栈跟踪。\n\n3. **调试器**：\n- 如果启用了调试器（`debug=True`），可以在错误页面中执行 Python 代码，帮助调试问题。\n\n#### **3.4.3 注意事项**\n- **不要在生产环境中启用调试模式**：\n- 调试模式会暴露应用的内部信息，存在安全风险。"
  },
  {
    "title": "目录",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%9B%AE%E5%BD%95.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/目录.md",
    "content": "### **2. 环境准备**\n- 2.1 安装 Python 和 Flask\n- 2.2 创建虚拟环境\n- 2.3 安装常用库（Flask-RESTful、Flask-SQLAlchemy 等）\n\n\n### **4. 构建第一个 RESTful API**\n- 4.1 使用 Flask-RESTful\n- 4.2 定义资源类\n- 4.3 处理 GET、POST、PUT、DELETE 请求\n- 4.4 返回 JSON 数据\n\n\n### **6. 数据库集成**\n- 6.1 使用 Flask-SQLAlchemy 进行数据库操作\n- 6.2 定义模型类\n- 6.3 数据库迁移（Flask-Migrate）\n- 6.4 实现 CRUD 操作\n\n\n### **8. 错误处理与日志**\n- 8.1 自定义错误处理\n- 8.2 返回标准化的错误响应\n- 8.3 使用 Flask-Logging 记录日志\n- 8.4 集成 Sentry 进行错误追踪\n\n\n### **10. API 文档与测试**\n- 10.1 使用 Flasgger 自动生成 Swagger 文档\n- 10.2 编写单元测试（Flask-Testing、pytest）\n- 10.3 使用 Postman 测试 API\n\n\n### **12. 实战项目**\n- 12.1 项目需求分析\n- 12.2 设计数据库模型\n- 12.3 实现核心功能（用户管理、产品管理）\n- 12.4 编写测试用例\n- 12.5 部署上线\n\n\n## **小册子特点**\n1. **循序渐进**：从基础到进阶，适合不同水平的开发者。\n2. **实战导向**：每个章节都包含代码示例和实战练习。\n3. **全面覆盖**：涵盖 RESTful API 开发的各个方面，包括数据库、认证、文档、测试和部署。\n4. **工具丰富**：介绍常用的 Flask 扩展库和工具，如 Flask-RESTful、Flask-SQLAlchemy、Flasgger 等。\n\n\n如果你需要更详细的内容或代码示例，可以告诉我具体的章节，我会为你提供更详细的解释和示例代码！ 😄"
  },
  {
    "title": "11. 部署与优化",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/11.%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BC%98%E5%8C%96.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/11. 部署与优化.md",
    "content": "### **11.2 使用 Nginx 作为反向代理**\n\n#### **11.2.1 什么是 Nginx？**\nNginx 是一个高性能的 HTTP 服务器和反向代理服务器，常用于负载均衡和静态文件服务。\n\n#### **11.2.2 安装 Nginx**\n在 Ubuntu 上安装 Nginx：\n```bash\nsudo apt update\nsudo apt install nginx\n```\n\n#### **11.2.3 配置 Nginx**\n1. 编辑 Nginx 配置文件：\n```bash\nsudo nano /etc/nginx/sites-available/myapp\n```\n\n2. 添加以下内容：\n```nginx\nserver {\nlisten 80;\nserver_name your_domain.com;\n\nlocation / {\nproxy_pass http://127.0.0.1:8000;\nproxy_set_header Host $host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n}\n}\n```\n\n3. 创建符号链接并重启 Nginx：\n```bash\nsudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled/\nsudo nginx -t  # 测试配置文件\nsudo systemctl restart nginx\n```\n\n#### **11.2.4 访问应用**\n通过浏览器访问 `http://your_domain.com`，即可看到 Flask 应用。\n\n\n### **11.4 性能优化建议**\n\n#### **11.4.1 使用缓存**\n- **Flask-Caching**：缓存频繁访问的数据，减少数据库查询。\n- **Redis**：作为分布式缓存，提升缓存性能。\n\n#### **11.4.2 数据库优化**\n- **索引**：为常用查询字段添加索引。\n- **分页**：减少单次查询的数据量。\n- **连接池**：使用数据库连接池，减少连接开销。\n\n#### **11.4.3 异步任务**\n- **Celery**：将耗时任务（如发送邮件、处理文件）放到后台执行。\n\n#### **11.4.4 静态文件服务**\n- **Nginx**：使用 Nginx 提供静态文件服务，减轻 Flask 的负担。\n\n#### **11.4.5 代码优化**\n- **减少数据库查询**：使用 `joinedload` 或 `subqueryload` 优化关联查询。\n- **避免重复计算**：缓存计算结果，减少 CPU 开销。"
  },
  {
    "title": "集成 OAuth 和 OIDC 实现单点登录（SSO）**",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/%E9%9B%86%E6%88%90%20OAuth%20%E5%92%8C%20OIDC%20%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89%2A%2A.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/集成 OAuth 和 OIDC 实现单点登录（SSO）**.md",
    "content": "### **13.4.2 使用 Flask-OAuthlib 实现 OAuth**\n\n#### **13.4.2.1 安装 Flask-OAuthlib**\n```bash\npip install Flask-OAuthlib\n```\n\n#### **13.4.2.2 配置 OAuth 客户端**\n以下是一个使用 GitHub 作为 OAuth 提供者的示例：\n```python\nfrom flask import Flask, redirect, url_for, session\nfrom flask_oauthlib.client import OAuth\n\napp = Flask(__name__)\napp.secret_key = 'your-secret-key'\n\noauth = OAuth(app)\n\ngithub = oauth.remote_app(\n'github',\nconsumer_key='your-github-client-id',\nconsumer_secret='your-github-client-secret',\nrequest_token_params={'scope': 'user:email'},\nbase_url='https://api.github.com/',\nrequest_token_url=None,\naccess_token_method='POST',\naccess_token_url='https://github.com/login/oauth/access_token',\nauthorize_url='https://github.com/login/oauth/authorize'\n)\n\n@app.route('/login')\ndef login():\nreturn github.authorize(callback=url_for('authorized', _external=True))\n\n@app.route('/logout')\ndef logout():\nsession.pop('github_token', None)\nreturn 'Logged out'\n\n@app.route('/login/authorized')\ndef authorized():\nresponse = github.authorized_response()\nif response is None or response.get('access_token') is None:\nreturn 'Access denied: reason={} error={}'.format(\nrequest.args['error_reason'],\nrequest.args['error_description']\n)\n\nsession['github_token'] = (response['access_token'], '')\nreturn 'Logged in as: {}'.format(github.get('user').data['login'])\n\n@github.tokengetter\ndef get_github_oauth_token():\nreturn session.get('github_token')\n\nif __name__ == '__main__':\napp.run(debug=True)\n```\n\n#### **13.4.2.3 注册 GitHub OAuth 应用**\n1. 登录 GitHub，进入 **Settings** -> **Developer settings** -> **OAuth Apps**。\n2. 点击 **New OAuth App**，填写应用信息。\n3. 获取 `Client ID` 和 `Client Secret`，替换代码中的 `your-github-client-id` 和 `your-github-client-secret`。\n\n\n### **13.4.4 常见问题解答（FAQ）**\n\n#### **Q1：OAuth 和 OIDC 有什么区别？**\n- **OAuth**：主要用于授权，允许第三方应用访问用户资源。\n- **OIDC**：在 OAuth 的基础上增加了身份验证功能，提供用户身份信息。\n\n#### **Q2：如何选择 OAuth 提供者？**\n- 根据需求选择提供者。例如：\n- **GitHub**：适合开发者社区。\n- **Google**：适合普通用户。\n- **Microsoft**：适合企业用户。\n\n#### **Q3：如何保护 OAuth 和 OIDC 的敏感信息？**\n- 使用环境变量存储 `Client ID` 和 `Client Secret`。\n- 使用 HTTPS 加密通信。\n\n#### **Q4：如何处理 OAuth 和 OIDC 的回调？**\n- 确保回调 URL 与注册的应用配置一致。\n- 在回调路由中处理授权码并获取访问令牌。"
  },
  {
    "title": "6. 数据库集成",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/6.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/6. 数据库集成.md",
    "content": "### **6.2 定义模型类**\n\n#### **6.2.1 什么是模型类？**\n模型类是数据库表的 Python 表示。每个模型类对应一张表，类的属性对应表的字段。\n\n#### **6.2.2 定义用户模型类**\n以下是一个用户模型类的示例：\n```python\nclass User(db.Model):\nid = db.Column(db.Integer, primary_key=True)  # 主键\nusername = db.Column(db.String(50), unique=True, nullable=False)  # 用户名，唯一且非空\nemail = db.Column(db.String(100), unique=True, nullable=False)  # 邮箱，唯一且非空\n\ndef __repr__(self):\nreturn f'<User {self.username}>'\n```\n\n- **字段类型**：\n- `db.Integer`：整数字段。\n- `db.String`：字符串字段。\n- `db.Boolean`：布尔字段。\n- `db.DateTime`：日期时间字段。\n\n- **字段参数**：\n- `primary_key`：是否为主键。\n- `unique`：是否唯一。\n- `nullable`：是否允许为空。\n\n#### **6.2.3 创建数据库表**\n在终端中运行以下命令创建数据库表：\n```bash\nflask shell\n>>> from app import db\n>>> db.create_all()\n```\n\n这会在项目目录下生成一个 SQLite 数据库文件 `mydatabase.db`，并创建 `User` 表。\n\n\n### **6.4 实现 CRUD 操作**\n\n#### **6.4.1 创建（Create）**\n- **添加新用户**：\n```python\nnew_user = User(username='Alice', email='alice@example.com')\ndb.session.add(new_user)\ndb.session.commit()\n```\n\n#### **6.4.2 读取（Read）**\n- **获取所有用户**：\n```python\nusers = User.query.all()\n```\n\n- **获取单个用户**：\n```python\nuser = User.query.get(1)  # 获取 ID 为 1 的用户\n```\n\n- **条件查询**：\n```python\nuser = User.query.filter_by(username='Alice').first()\n```\n\n#### **6.4.3 更新（Update）**\n- **更新用户信息**：\n```python\nuser = User.query.get(1)\nuser.email = 'new_email@example.com'\ndb.session.commit()\n```\n\n#### **6.4.4 删除（Delete）**\n- **删除用户**：\n```python\nuser = User.query.get(1)\ndb.session.delete(user)\ndb.session.commit()\n```\n\n\n## **总结**\n通过本章的学习，你已经掌握了以下内容：\n1. 如何使用 Flask-SQLAlchemy 进行数据库操作。\n2. 如何定义模型类并创建数据库表。\n3. 如何使用 Flask-Migrate 进行数据库迁移。\n4. 如何实现 CRUD 操作。\n\n接下来，我们将进入 **7. 用户认证与授权**，学习如何使用 Flask-JWT-Extended 实现 JWT 认证。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "8. 错误处理与日志",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/8.%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%97%A5%E5%BF%97.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/8. 错误处理与日志.md",
    "content": "### **8.2 返回标准化的错误响应**\n\n#### **8.2.1 什么是标准化的错误响应？**\n标准化的错误响应是指所有错误都遵循相同的格式，便于客户端解析和处理。\n\n#### **8.2.2 示例：标准化的错误响应**\n定义一个通用的错误响应格式：\n```python\ndef error_response(message, status_code):\nreturn jsonify({\n'success': False,\n'error': {\n'code': status_code,\n'message': message\n}\n}), status_code\n```\n\n在错误处理中使用：\n```python\n@app.errorhandler(404)\ndef not_found(error):\nreturn error_response('Resource not found', 404)\n\n@app.errorhandler(500)\ndef internal_error(error):\nreturn error_response('Internal server error', 500)\n```\n\n#### **8.2.3 返回示例**\n- **404 错误**：\n```json\n{\n\"success\": false,\n\"error\": {\n\"code\": 404,\n\"message\": \"Resource not found\"\n}\n}\n```\n\n- **500 错误**：\n```json\n{\n\"success\": false,\n\"error\": {\n\"code\": 500,\n\"message\": \"Internal server error\"\n}\n}\n```\n\n\n### **8.4 集成 Sentry 进行错误追踪**\n\n#### **8.4.1 什么是 Sentry？**\nSentry 是一个开源的错误追踪工具，可以帮助开发者实时监控和修复应用中的错误。\n\n#### **8.4.2 安装 Sentry**\n如果你还没有安装 Sentry，可以通过以下命令安装：\n```bash\npip install sentry-sdk[flask]\n```\n\n#### **8.4.3 配置 Sentry**\n在 `app.py` 中配置 Sentry：\n```python\nimport sentry_sdk\nfrom sentry_sdk.integrations.flask import FlaskIntegration\n\n# 初始化 Sentry\nsentry_sdk.init(\ndsn='your-sentry-dsn',  # 替换为你的 Sentry DSN\nintegrations=[FlaskIntegration()],\ntraces_sample_rate=1.0\n)\n```\n\n- **dsn**：Sentry 项目的 DSN（数据源名称）。\n- **FlaskIntegration**：集成 Flask 应用。\n- **traces_sample_rate**：采样率（0.0 到 1.0）。\n\n#### **8.4.4 测试 Sentry**\n在代码中触发一个错误，Sentry 会自动捕获并记录：\n```python\n@app.route('/sentry-error')\ndef sentry_error():\ndivision_by_zero = 1 / 0  # 触发错误\nreturn 'This will not be reached'\n```\n\n\n## **总结**\n通过本章的学习，你已经掌握了以下内容：\n1. 如何自定义错误处理并返回标准化的错误响应。\n2. 如何使用 Flask-Logging 记录日志。\n3. 如何集成 Sentry 进行错误追踪。\n\n接下来，我们将进入 **9. 高级功能**，学习如何实现分页、缓存和文件上传等高级功能。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "9. 高级功能",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/9.%20%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/9. 高级功能.md",
    "content": "### **9.2 缓存（Flask-Caching）**\n\n#### **9.2.1 什么是缓存？**\n缓存是将频繁访问的数据存储在内存中，以减少数据库查询或计算的开销。\n\n#### **9.2.2 安装 Flask-Caching**\n如果你还没有安装 Flask-Caching，可以通过以下命令安装：\n```bash\npip install Flask-Caching\n```\n\n#### **9.2.3 配置缓存**\n在 `app.py` 中配置缓存：\n```python\nfrom flask_caching import Cache\n\napp.config['CACHE_TYPE'] = 'SimpleCache'  # 使用简单缓存\napp.config['CACHE_DEFAULT_TIMEOUT'] = 300  # 缓存默认过期时间（秒）\n\ncache = Cache(app)\n```\n\n#### **9.2.4 使用缓存**\n- **缓存视图函数**：\n```python\n@app.route('/cached')\n@cache.cached(timeout=60)  # 缓存 60 秒\ndef cached():\nreturn 'This response is cached'\n```\n\n- **缓存数据**：\n```python\n@app.route('/users', methods=['GET'])\ndef get_users():\nusers = cache.get('users')\nif users is None:\nusers = [user.username for user in User.query.all()]\ncache.set('users', users, timeout=60)\nreturn jsonify(users)\n```\n\n\n### **9.4 异步任务（Celery）**\n\n#### **9.4.1 什么是异步任务？**\n异步任务是指将耗时操作（如发送邮件、处理文件）放到后台执行，避免阻塞主线程。\n\n#### **9.4.2 安装 Celery**\n如果你还没有安装 Celery，可以通过以下命令安装：\n```bash\npip install celery\n```\n\n#### **9.4.3 配置 Celery**\n在 `app.py` 中配置 Celery：\n```python\nfrom celery import Celery\n\napp.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\n\ncelery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])\ncelery.conf.update(app.config)\n```\n\n#### **9.4.4 定义异步任务**\n- **示例：发送邮件任务**\n```python\n@celery.task\ndef send_email(email, message):\n# 模拟发送邮件\nimport time\ntime.sleep(5)\nprint(f'Email sent to {email}: {message}')\n```\n\n#### **9.4.5 调用异步任务**\n在视图函数中调用异步任务：\n```python\n@app.route('/send-email', methods=['POST'])\ndef send_email_route():\ndata = request.get_json()\nemail = data.get('email')\nmessage = data.get('message')\nsend_email.delay(email, message)  # 异步调用\nreturn jsonify({'message': 'Email is being sent'}), 202\n```\n\n\n## **总结**\n通过本章的学习，你已经掌握了以下内容：\n1. 如何实现分页与过滤。\n2. 如何使用 Flask-Caching 进行缓存。\n3. 如何处理文件上传与存储。\n4. 如何使用 Celery 实现异步任务。\n\n接下来，我们将进入 **10. API 文档与测试**，学习如何生成 API 文档和编写测试用例。如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  },
  {
    "title": "1. 简介",
    "created": "2025-03-21T11:28:23.166102",
    "updated": "2025-03-21T11:28:23.166102",
    "category": "Uncategorized",
    "subcategory": "",
    "tags": [],
    "url": "obsidian://open?vault=markdown&file=%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/Flask%20RESTful%20API%20%E5%B0%8F%E5%86%8C%E5%AD%90/1.%20%E7%AE%80%E4%BB%8B.md",
    "lang": "en",
    "filepath": "开源软件/Flask RESTful API 小册子/1. 简介.md",
    "content": "### **1.2 为什么选择 Flask 构建 RESTful API？**\n\n#### **1.2.1 Flask 的特点**\nFlask 是一个轻量级的 Python Web 框架，具有以下特点：\n1. **轻量灵活**：\n- Flask 核心功能简单，没有过多的约束，开发者可以根据需求自由选择扩展库。\n- 适合快速开发小型项目或原型。\n\n2. **易于学习**：\n- Flask 的 API 设计简洁明了，学习曲线低，适合初学者。\n- 文档丰富，社区支持强大。\n\n3. **扩展性强**：\n- 通过集成各种扩展库（如 Flask-RESTful、Flask-SQLAlchemy），可以实现复杂的功能。\n- 支持数据库操作、用户认证、API 文档生成等。\n\n4. **高性能**：\n- Flask 本身性能较高，适合构建高性能的 API 服务。\n- 可以通过异步任务（如 Celery）进一步提升性能。\n\n5. **适合微服务**：\n- Flask 的轻量特性使其非常适合构建微服务架构中的单个服务。\n\n#### **1.2.2 Flask 与其他框架的对比**\n| 框架          | 特点                          | 适用场景                     |\n|---------------|-------------------------------|------------------------------|\n| Flask         | 轻量、灵活                    | 小型项目、RESTful API         |\n| Django        | 全功能、自带 ORM              | 中大型项目、全栈开发          |\n| FastAPI       | 高性能、异步、自动文档         | 高性能 API、实时应用          |\n| Tornado       | 异步、高并发                  | 实时应用、长连接服务          |\n\n#### **1.2.3 Flask 的生态系统**\nFlask 拥有丰富的扩展库，可以快速实现各种功能：\n- **数据库**：Flask-SQLAlchemy、Flask-Migrate\n- **用户认证**：Flask-Login、Flask-JWT-Extended\n- **API 文档**：Flasgger\n- **表单处理**：Flask-WTF\n- **文件上传**：Flask-Uploads\n- **缓存**：Flask-Caching\n\n\n## **总结**\n本章介绍了 RESTful API 的概念、选择 Flask 的原因以及小册子的目标和结构。通过本章的学习，你应该对 RESTful API 和 Flask 有了初步的了解。接下来，我们将从 Flask 的基础开始，逐步构建一个完整的 RESTful API。\n\n如果你有任何问题，或者需要更详细的解释和代码示例，随时告诉我！ 😄"
  }
]